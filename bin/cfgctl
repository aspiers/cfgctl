#!/usr/bin/perl

=head1 NAME

cfgctl - configuration file controller

=head1 SYNOPSIS

    $ cfgctl [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:

  -n, --dry-run              Don't touch the disk
  -d, --debug                Debug
  -p, --pkg-dir=DIR          Change source package directory [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$TARGET_DIR]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
  -T, --thorough             Don't prune subdirectories not in packages.
                             This may leave symlinks pointing to old
                             dirs which used to be in packages, but is
                             a lot slower.

=head1 DESCRIPTION

Blah blah.  Explain why this is a good idea.

=head1 ARCHITECTURE

The pathname strategy involves multiple levels of symlinks, e.g.:

 (1)                      ~/bin/cpan    # These are the filenames
                                |--|    # which actually get used
                        symlink   |     # as config etc.
                                  v
                                |--|    # Flat namespace required for 
 (2)       ~/.cfg/perl+mine/bin/cpan    # stow or other package       
                  |-------|             # management tool.  Only one  
                      \_________        # tool should ever be used at 
                                \       # any given time, hence it's  
                        symlink  |      # nicer to call it ~/.cfg than
                                 v      # ~/.Stow or similar. 
                              |-------| 
 (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan   # for flexible
                                                   # sourcecontrol

Explanation and justification of this design follows:

=over 4

=item * Clear demarcation of responsibility

  + The symlinks between (1) and (2) are managed entirely by the
    chosen package management tool (currently stow).

  + The symlinks between (2) and (3) are managed entirely by this
    program and the etc/config.map file.

=item * Flexibility

The flexibility of mapping between (2) and (3) offered by the
etc/config.map file lets us squash multiple sources into the
same unique package namespace.  Advantages:

  + Can have parallel public/private/RETIRED hierarchies
    within the CVS repository.

  + Could even manage config concurrently from several different
    source control systems.

=item * Cooperation with source control system

'config' is currently a single CVS module so (3) must contain a
directory called 'config' for clean check-out.

=back

=head2 CAVEAT

We avoid ~/.stow because stow interprets ".stow" existing in a
directory as a flag meaning that that directory is a stow directory
containing stow source packages.  As a result it will not remove any
stow symlinks from that directory, but we certainly want it to remove
stow symlinks from under ~

=head1 TODO

=over 4

=item * Perlify config file

so can have flexible conditionals for inclusion, e.g.

  my $personal = 1;
  ...
  if ($personal) {
    map();

=back

=cut

# Now we define some sensible default settings for the top-level
# container directories corresponding to each level above:

# (1) Where the all-important end-user symlinks go.
$cfg{TARGET_DIR}  = $ENV{HOME};

# (2) Package directory ("stow directory" in stow terminology).
#     stow requires all packages live immediately under this.
$cfg{PKG_DIR}     = "$ENV{HOME}/.cfg";

# We use a slightly hacked-up version of GNU stow which ignores CVS/
# directories.
$cfg{STOW}        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
$cfg{MAP_FILE}    = abs_path("$RealBin/../etc/config.map");

##############################################################################

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin $RealScript);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use File::Compare;
use Sh qw(abs_path);
use Cfg;
use Cfg::Utils qw(%opts %cfg);

Getopt::Long::Configure('no_ignore_case');
GetOptions(
  \%opts,
  'dry-run|n', 'sources|s', 'destinations|d', 'verbose|v+',
  'pkg-dir|p=s', 'target|t=s', 'map|m=s',
  'delete|D', 'remove-dangling|r', 'thorough|T',
)
  or usage();

sub usage {
  warn @_, "\n" if @_;

  die <<EOUSAGE;
$RealScript [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:
  -s, --sources              Only list source packages
  -D, --destinations         Only list destination packages
  -n, --dry-run              Don't touch the disk
  -v, --verbose              Increase verbosity
  -p, --pkg-dir=DIR          Change source package [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$cfg{TARGET_DIR}]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
EOUSAGE
}

$cfg{PKG_DIR}     = $opts{'pkg-dir'} if $opts{'pkg-dir'};
$cfg{TARGET_DIR}  = $opts{'target' } if $opts{'target' };
$cfg{MAP_FILE}    = $opts{'map'    } if $opts{'map'    };

-d $cfg{TARGET_DIR}
  or usage("$cfg{TARGET_DIR} is not a valid directory; aborting.\n");
-e $cfg{MAP_FILE}
  or usage("$cfg{MAP_FILE} does not exist; did you copy from $cfg{MAP_FILE}.template?\n");
-e $cfg{STOW}
  or usage("$cfg{STOW} not found!  Aborting.\n");

lstat($cfg{PKG_DIR});
if (-e _) {
  -d _ or usage("$cfg{PKG_DIR} must be a directory!  Aborting.\n");
}
else {
  mkdir $cfg{PKG_DIR} or die "mkdir($cfg{PKG_DIR}) failed: $!\n";
}

Cfg->do_registration();

if ($opts{sources} || $opts{destinations}) {
  Cfg->list_pkgs();
  exit 0;
}

Cfg->process_pkgs();

exit 0;

