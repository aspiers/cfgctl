#!/usr/bin/perl

=head1 NAME

cfgctl - configuration file controller

=head1 SYNOPSIS

    $ cfgctl [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:

  -n, --dry-run              Don't touch the disk
  -d, --debug                Debug
  -p, --pkg-dir=DIR          Change source package directory [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$TARGET_DIR]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
  -T, --thorough             Don't prune subdirectories not in packages.
                             This may leave symlinks pointing to old
                             dirs which used to be in packages, but is
                             a lot slower.

=head1 MOTIVATION

Home directories on UNIX-like systems contain a wealth of
configuration data, which is typically treated as a "second-class
citizen" in comparison to source code.  The latter is generally
subject to standard modern software configuration management best
practices which allow consistent deployment, auditing, roll-back and
so on, whereas the former is usually managed in an ad-hoc and
uncontrolled manner.

There appears to be no reasonable justification for this inequality of
treatment with respect to configuration based in home directories.  It
is this writer's belief that it exists for the following reasons:

=over 4

=item * It's awkward to manage.

Configuration usually lives directly under the home directory rather
than in several conveniently self-contained trees which can easily be
checked into a source code control system.

=item * It often blurs the lines between code and data.

For example, options set in your shell profile are conceptually
configuration data, but are implemented by running shell code commands
(set/setopt etc.)

=item * Most people don't bother with complex configurations anyway, and

=item * configuration is often mostly forgotten about after start-up costs.

Many people only configure to "scratch an itch".

=item * Many people don't frequently use more than one system.

=item * Some configuration is auto-generated by a front-end.

Therefore the user is often unaware of the back-end files even existing.

=item * System administrators generally take a very hands-off approach. 

With the exception of the canonical template skeleton user home
directory (e.g. F</etc/skel>) which is used to populate a new home
directory after creation, generally system administrators do not
attempt to change per-user configuration data in any way.  Taking a
naive political view, this would appear to be a very good thing ("get
your hands off MY files!").  However, many system administrators would
most likely not think twice about upgrading a system-wide package,
which could have exactly the same effect.  For example, imagine an
application C<foo> which looks for configuration data in
F</etc/foo/default.rc> and F<~/.foorc>.  After an upgrade which
changed the contents of F</etc/foo/default.rc>, a user might or might
not see different behaviour from the application, depending on:

    (a) whether F<~/.foorc> completely overrides F<default.rc> if
        present, or merely inherits defaults from F<default.rc> and
        then overrides them on a case-by-case basis, and

    (b) whether on the user's first invocation of the application,
        the application creates F<~/.foorc> before or after the user
        customises any options.

Now imagine that the application actually uses several per-user
configuration files.  (This is a very common scenario.)  Perhaps it
makes sense for some of these files to be configured site-wide, but
others per-user.  The traditional approach above may not be capable of
yielding the right results.

=back

It seems clear that for anyone who uses more than one system, is fussy
about how they configure their tools, and wants consistent,
reproducible, audited, well-controlled configuration across multiple
systems, some kind of configuration management tool is required.

=head1 DESCRIPTION

This program aims to be that tool.  It divides configuration into
well-defined "chunks" (stow packages) which can be managed by the
user's favourite source code control tool(s).  It then reuses the code
and functionality of GNU stow in order to install the files within
these packages into the expected location within the home directory
for normal operation.

=head1 ARCHITECTURE

The pathname strategy involves two levels of symlinks.  We take the
example of a simple shell-script called F<cpan> which invokes the
well-known CPAN shell and is required to live under F<~/bin>.  We
could just as easily have taken a more typical configuration file such
as F<~/.bashrc>, but for illustrative purposes it is better to choose
something which does not live directly under F<~>.

 (1)                      ~/bin/cpan             "install targets"
                                  | 
                                  |              "install symlinks"
                                  V
 (2)       ~/.cfg/perl+mine/bin/cpan             "install sources"
                  <------->                      "pkg name"
           <-------------->                      "cfg target"
                      \_____________
                                    \
                                    |            "cfg symlink"
                                    V
      <------------------------------->          "cfg source"
 (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan

=head2 Explanation

(N.B. In the following text, the use of the words "source" and
"target" may appear backwards to what would be intuitively expected.
This is because the mechanism used to "install" from "source" to
"target" is symlinking, which results in a symlink pointing from the
"target" back to the "source".  For example, see the L<ln(1)> man page
for somewhat contradictory terminology, where "target" refers to the
thing being pointed to.  So here we could say that the "cfg source" is
the target of the "cfg symlink", if we wanted to be really confusing!)

At the first level of symlinks, we have the "install targets" (1)
which are the pathnames which actually get used as config etc.  They
are "install symlinks" pointing to the "install sources" pathnames (2)
(unless stow folding is used, in which case the same will be true for
a containing directory).  There will usually be many of these for each
package.

At the second level, we have one "cfg symlink" per package pointing
from a "cfg target" to a "cfg source" directory.  This provides a flat
package namespace as required for stow or other package management
tool.  Only one tool should ever be used at any given time, hence it's
nicer to call it F<~/.cfg> than F<~/.Stow> or similar.

(An additional reason for not calling it F<~/.stow> is that stow
interprets any directory entry F<.stow> as a flag meaning that that
directory is a stow directory containing stow source packages.  As a
result it will not remove any stow symlinks from that directory, but
we certainly want it to remove stow symlinks from under F<~>.)

=head2 Justification

=over 4

=item * Flexibility

The flexibility of this two-layer mapping lets us squash multiple
sources into the same unique package namespace.  Advantages:

  + Allows use and management of config concurrently from several
    different source control systems / repositories.

  + Can use parallel public/private/"retired" hierarchies within one
    source control system (e.g. within one CVS/Subversion repository).

=item * Clear demarcation of responsibility

  + The symlinks between (1) and (2) are managed entirely by the
    chosen package management tool (currently stow).  The code will
    refer to them as "install symlinks".

  + The symlinks between (2) and (3) are managed entirely by this
    program and the F<etc/config.map> file.  The code will refer to
    them as "cfg symlinks".

=item * Cooperation with source control system

F<config> is currently a single CVS module so (3) must contain a
directory called F<config> for clean check-out.

=back

=head1 TODO

=over 4

=item * Support more source code control systems.

This is accomplished by adding more subclasses of C<Cfg::Pkg::Base>.

=back

=cut

# Now we define some sensible default settings for the top-level
# container directories corresponding to each level above:

# (1) Where the all-important end-user symlinks go.
$cfg{TARGET_DIR}  = $ENV{HOME};

# (2) Package directory ("stow directory" in stow terminology).
#     stow requires all packages live immediately under this.
$cfg{PKG_DIR}     = "$ENV{HOME}/.cfg";

# We use a slightly hacked-up version of GNU stow which ignores CVS/
# directories and anything in ~/.cvsignore.
$cfg{STOW}        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
$cfg{MAP_FILE}    = abs_path("$RealBin/../etc/config.map");

##############################################################################

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin $RealScript);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use Sh qw(abs_path);
use Cfg;
use Cfg::Utils qw(%opts %cfg);

Getopt::Long::Configure('no_ignore_case');
GetOptions(
  \%opts,
  'dry-run|n', 'sources|s', 'destinations|d', 'verbose|v+',
  'pkg-dir|p=s', 'target|t=s', 'map|m=s',
  'delete|D', 'remove-dangling|r', 'thorough|T',
)
  or usage();

sub usage {
  warn @_, "\n" if @_;

  ### N.B.!  If you change the below, don't forget to update the
  ### SYNOPSIS too!
  die <<EOUSAGE;
$RealScript [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:
  -s, --sources              Only list source packages
  -D, --destinations         Only list destination packages
  -n, --dry-run              Don't touch the disk
  -v, --verbose              Increase verbosity
  -p, --pkg-dir=DIR          Change source package [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$cfg{TARGET_DIR}]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
EOUSAGE
}

$cfg{PKG_DIR}     = $opts{'pkg-dir'} if $opts{'pkg-dir'};
$cfg{TARGET_DIR}  = $opts{'target' } if $opts{'target' };
$cfg{MAP_FILE}    = $opts{'map'    } if $opts{'map'    };

-d $cfg{TARGET_DIR}
  or usage("$cfg{TARGET_DIR} is not a valid directory; aborting.\n");
-e $cfg{MAP_FILE}
  or usage("$cfg{MAP_FILE} does not exist; did you copy from $cfg{MAP_FILE}.template?\n");
-e $cfg{STOW}
  or usage("$cfg{STOW} not found!  Aborting.\n");

lstat($cfg{PKG_DIR});
if (-e _) {
  -d _ or usage("$cfg{PKG_DIR} must be a directory!  Aborting.\n");
}
else {
  mkdir $cfg{PKG_DIR} or die "mkdir($cfg{PKG_DIR}) failed: $!\n";
}

Cfg->do_registration();

if ($opts{sources} || $opts{destinations}) {
  Cfg->list_pkgs();
  exit 0;
}

Cfg->process_pkgs();

exit 0;

