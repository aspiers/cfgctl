#!/usr/bin/perl

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use File::Compare;
use Sh qw(abs_path move_with_subpath);

# Pathname strategy involves multiple levels of symlinks, e.g.:
#
# (1)                                  ~/bin/cpan # these actually get used!
#                                            vvvv 
# (2)        ~/.Stow/dev-tools+perl+mine/bin/cpan # flat namespace required for stow
#                                   vvvv
# (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan # for flexible sourcecontrol
#               ^^^^
# (4)         ~/.cfg/dev-tools/perl/mine/bin/cpan # for convenience
#
# Note:
#
#   * We use ~/.Stow not ~/.stow because stow interprets ".stow"
#     existing in a directory as a flag meaning that that directory is
#     a stow directory containing stow source packages.  As a result
#     it will not remove any stow symlinks from there, but we certainly
#     want it to remove stow symlinks from under ~
#
#   * 'config' is a single CVS module so (3) must contain a directory
#     called 'config'.
#
#   * (1) links to (2) not (4) because an extra level of indirection is
#     inefficient, even if it makes `ls -la ~/.*' more legible.
#
#   * We allow room for expansion via packages prefixed with something
#     other than 'config/'.  It may make sense to label them something
#     other than 'config' but still include them in the same stow
#     repository.

# Now we define the top-level container directories corresponding to
# each level:

# (1) Where the all-important symlinks go.
#my $TARGET_DIR  = "$ENV{HOME}/tmp/config-stow-test";
my $TARGET_DIR  = $ENV{HOME};

# (2) Stow directory - stow requires all packages live immediately under this.
my $STOW_DIR    = "$ENV{HOME}/.Stow";

# (3) Root of the checked-out config tree.  We work it out by assuming
#     that this file is in the directory $wd/config/META/bin.
my $CO_CFG_ROOT = abs_path("$RealBin/../..");

# (4) For CLI convenience only.
my $CONVENIENCE_DIR = "$ENV{HOME}/.cfg";

# The source code control system's working directory which contains
# the checked out config.
my $CVS_ROOT_WD = abs_path("$CO_CFG_ROOT/..");

# We use a slightly hacked-up version of GNU stow which ignores CVS/ directories.
my $STOW        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
my $MAP_FILE    = abs_path("$RealBin/../etc/config.map");

my %opts;
Getopt::Long::Configure('no_ignore_case');
GetOptions(\%opts, 'dry-run|n', 'delete|D', 'debug|d')
  or die "Bad options";
my $for_real = $opts{'dry-run'} ? 0 : 1;

-e $MAP_FILE
  or die "$MAP_FILE does not exist; did you copy from $MAP_FILE.template?\n";
-e $CO_CFG_ROOT
  or die "$CO_CFG_ROOT does not exist; is the stuff really checked out yet?\n";
-e $STOW
  or die "$STOW not found!  Aborting.\n";

if (! -d $STOW_DIR) {
  mkdir $STOW_DIR or die "mkdir($STOW_DIR) failed: $!\n";
}
ensure_correct_symlink($CONVENIENCE_DIR, $CO_CFG_ROOT);

if (@ARGV) {
  foreach my $pkg (@ARGV) {
    process_pkg($pkg);
  }
}
else {
  process_pkgs_from_config();
}

TempDir->cleanup();

exit 0;

sub process_pkgs_from_config {
  open(MAP, $MAP_FILE) or die "open($MAP_FILE) failed: $!\n";
  while (<MAP>) {
    if (/^\s*\#\@/) {
      print;
      next;
    }
    next if /^\s*(\#|$)/;

    chomp;
    s/^\s+//;
    s/\s+$//;

    process_pkg($_);
  }
}

sub process_pkg {
  my ($pkg) = @_;

  (my $dst = $pkg) =~ s!^config/!!
    or die "Non-config not supported yet";

  if (! -d "$CO_CFG_ROOT/$dst") {
    check_out_pkg($pkg);
  }
  else {
    #print "# $dst already checked out in $CO_CFG_ROOT\n";
  }

  if ($pkg =~ /RETIRE/) {
    print "#! deprecating: $pkg\n";
    deprecate_pkg($dst);
  }
  else {
    if ($opts{delete}) {
      delete_pkg($dst);
      print "# de-installed: $pkg\n";
    }
    else {
      install_pkg($dst);
      print "# installed: $pkg\n";
    }
  }
}

sub stowify_pkg {
  my ($pkg) = @_;
  my @segments = File::Spec->splitdir($pkg);
  my $stow_pkg = join '+', @segments;
  ensure_correct_symlink(
    File::Spec->join($STOW_DIR, $stow_pkg),
    File::Spec->join($CO_CFG_ROOT, $pkg),
  );
  return $stow_pkg;
}

sub check_out_pkg {
  my ($pkg) = @_;
  chdir($CVS_ROOT_WD) or die "chdir($CVS_ROOT_WD) failed: $!\n";
  print "Checking out $pkg ...\n";
  system 'cvs', 'checkout', $pkg;
  my $exit = $? >> 8;
  die "cvs checkout $pkg failed; aborting!\n" if $exit != 0;
}

sub deprecate_pkg {
  my ($pkg) = @_;
  #print "$pkg is deprecated; checking not installed ...\n";
  my $stow_pkg = stowify_pkg($pkg);
  system $STOW,
      '-c',            # Dummy run, checking for conflicts.  If we're
                       # not using the deprecated package, there won't
                       # be any.
      '-R',            # Remove any symlinks already there.
      '-t', $TARGET_DIR,
      '-d', $STOW_DIR,
      $stow_pkg;
  my $exit = $? >> 8;
  warn "$STOW -c failed; aborting!\n" if $exit != 0;
}

sub delete_pkg {
  my ($pkg) = @_;
  my $stow_pkg = stowify_pkg($pkg);
  system $STOW,
      ($for_real ? () : ( '-n' )),
      '-D', 
      '-t', $TARGET_DIR,
      '-d', $STOW_DIR,
      $stow_pkg;
  my $exit = $? >> 8;
  warn "$STOW -c failed; aborting!\n" if $exit != 0;
}

sub install_pkg {
  my ($pkg) = @_;
  my $stow_pkg  = stowify_pkg($pkg);
  my $stow_args = qq{-t "$TARGET_DIR" -d "$STOW_DIR" "$stow_pkg"};
  $stow_args = "-vvv $stow_args" if $opts{debug};
  my $cmd       = "$STOW -c -R $stow_args";
  (my $human_cmd = $cmd) =~ s!\b$ENV{HOME}/!~/!g;
  debug("preempt: $cmd\n");
  open(STOW, "$cmd 2>&1 |") or die "open($human_cmd|) failed: $!\n";
  while (<STOW>) {
    if (/^CONFLICT: (.+) vs. (.+?)( \(.*?\))?$/) {
      #print;
      my ($src, $symlink) = ($1, $2);
      preempt_conflict($src, $symlink);
      next;
    }
    
    #debug("! surplus stow -c output: $_");
    print "$_";
  }
  close(STOW) or die "close($human_cmd|) failed: $!\n";

  # Should have preempted all conflicts now; run for real.
  $cmd = "$STOW -R $stow_args";
  ($human_cmd = $cmd) =~ s!(^|\s)$ENV{HOME}/!$1~/!g;
  debug("post-preempt: $human_cmd\n");
  if ($for_real) {
    system $cmd;
    my $exit = $? >> 8;
    warn "$STOW failed; aborting!\n" if $exit != 0;
  }
}

sub preempt_conflict {
  my ($src, $symlink) = @_;

  # Shorter, human-readable versions of source file and symlink
  (my $human_src     = $src)     =~ s!^$ENV{HOME}/!~/!;
  (my $human_symlink = $symlink) =~ s!^$ENV{HOME}/!~/!;
  (my $sub_symlink   = $symlink) =~ s!^$TARGET_DIR/!!
    or die "$symlink didn't start with $TARGET_DIR\n";

  return if -d $symlink and -d $src;
  return "Only one of $human_symlink and $human_src is a directory; aborting!\n"
    if -d $symlink xor -d $src;

#   my $tempdir = TempDir->get;
#   die unless -d $tempdir;

  my ($src_dev,     $src_ino)     = stat($src)     or die "stat($src) failed: $!";
  my ($symlink_dev, $symlink_ino) = stat($symlink) or die "stat($symlink) failed: $!";

  if ($src_dev == $symlink_dev and $src_ino == $symlink_ino) {
    debug("$human_src and $human_symlink are the same file; must be false conflict (see 6.3 Conflicts section of manual)\n");
    return;
  }

  if (compare($src, $symlink) == 0) {
    # same file contents - remove target so that stow can put a
    # symlink there instead.
    debug("# $human_symlink == $src; remove to make way for symlink\n");
#     my $same_dir = File::Spec->join($tempdir, 'same');
#     die $same_dir unless -d $same_dir;
    if ($for_real) {
      unlink $symlink or die "unlink($symlink) to preempt conflict failed: $!\n";
      #move_with_subpath($TARGET_DIR, $same_dir, $sub_symlink);
    }
  }
  else {
    # different file contents - move target to source so that stow
    # can put a symlink there instead whilst still preserving
    # local changes
#     my $modified_dir = File::Spec->join($tempdir, 'modified');
    debug("# $human_symlink != $human_src; mv to preserve changes\n");
    if ($for_real) {
      rename $symlink, $src
	or die "rename($symlink, $src) to preempt conflict failed: $!\n";
      #move_with_subpath($TARGET_DIR, $modified_dir, $sub_symlink);
    }
  }
}

sub ensure_correct_symlink {
  my ($symlink, $required_target) = @_;

  if (! lstat $symlink) {
    symlink $required_target, $symlink
      or die "symlink($required_target, $symlink) failed: $!\n";
    return;
  }

  if (! -l $symlink) {
    die "$symlink already exists but is not a symlink; aborting!\n";
  }

  my ($a_dev, $a_ino) = stat($symlink) # stat automatically follows symlinks
    or die "stat($symlink) failed ($!); invalid symlink?\n";
  my ($r_dev, $r_ino) = stat($required_target)
    or die "stat($required_target) failed: $!";
  if ($a_dev != $r_dev or $a_ino != $r_ino) {
    die "$symlink already exists and points to the wrong place; aborting!\n";
  }
}

sub debug {
  print @_ if $opts{debug};
}

##############################################################################

package TempDir;

use File::Basename;
use File::Path;
use File::Spec;
use File::Temp qw/ tempfile tempdir /;

our $tempdir;
my $init = 0; # yuk
my @subdirs;

sub init {
  return if $init;
  @subdirs = (qw/same modified/);
  $init++;
}

sub get {
  shift->init();
  return $tempdir if $tempdir;
  my $me = basename($0);
  $tempdir = tempdir(".$me.XXXXXXXX", DIR => $TARGET_DIR);
  die "huh?" unless -d $tempdir;
  die unless @subdirs;
  foreach my $dir (@subdirs) {
    my $new = File::Spec->join($tempdir, $dir);
    mkdir($new) or die "mkdir($new) failed: $!\n";;
  }
  return $tempdir;
}

sub cleanup {
  return unless $tempdir and -d $tempdir;
  foreach my $dir (@subdirs) {
    my $doomed = File::Spec->join($tempdir, $dir);
    rmdir($doomed) or die "$doomed not empty?";
  }
  rmdir($tempdir) or die "rmdir($tempdir) failed: $!\n";
}

END {
  if ($tempdir and -e $tempdir) {
    warn "! Did not exit cleanly; $tempdir still exists.\n";
  }
}

1;
