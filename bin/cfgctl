#!/usr/bin/perl

=head1 NAME

cfgctl - configuration file controller

=head1 SYNOPSIS

    $ cfgctl [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:

  -n, --dry-run              Don't touch the disk
  -d, --debug                Debug
  -p, --pkg-dir=DIR          Change source package directory [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$TARGET_DIR]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
  -T, --thorough             Don't prune subdirectories not in packages.
                             This may leave symlinks pointing to old
                             dirs which used to be in packages, but is
                             a lot slower.

=head1 MOTIVATION

Home directories on UNIX-like systems contain a wealth of
configuration information.  This information is typically treated as
"second-class citizen" data relative to source code; the latter is
generally subject to standard modern software configuration management
best practices which allow consistent deployment, auditing, roll-back
and so on, whereas the former is usually managed in an ad-hoc and
uncontrolled manner.

There appears to be no reasonable justification for this inequality of
treatment with respect to configuration based in home directories.  It
is this writer's belief that it exists for the following reasons:

=over 4

=item * It's awkward to manage.

Configuration usually lives directly under the home directory rather
than in one conveniently self-contained tree which can easily be checked
into a source code control system.

=item * It often blurs the lines between code and data.

For example, setting options in your shell - conceptually data but
implemented by running commands in the shell profile.

=item * Most people don't bother with complex configurations anyway.

=item * Many people don't frequently use more than one system.

=item * Configuration is often mostly forgotten about after start-up costs.

Many people only configure to "scratch an itch".

=item * Some configuration is auto-generated by a front-end.

Therefore the user is often unaware of the back-end files even existing.

=back

It seems clear that for anyone who uses more than one system, is fussy
about how they configure their tools, and wants consistent,
reproducible, audited, well-controlled configuration across multiple
systems, some kind of configuration management tool is required.

=head1 DESCRIPTION

This program aims to be that tool.  It divides configuration into
well-defined "chunks" (stow packages) which can be managed by the
user's favourite source code control tool.  It then reuses the code
and functionality of GNU stow in order to install the files within
these packages into the expected location within the home directory
for normal operation.

=head1 ARCHITECTURE

The pathname strategy involves multiple levels of symlinks.  We take
the example of a simple shell-script called F<cpan> which invokes the
well-known CPAN shell and is required to live under F<~/bin>.  We
could just as easily have taken a more typical configuration file such
as F<~/.bashrc>, but for illustrative purposes it is better to choose
something which does not live directly under F<~>.

 (1)                      ~/bin/cpan    # These are the filenames
                                |--|    # which actually get used
                        symlink   |     # as config etc.
                                  v
                                |--|    # Flat namespace required for 
 (2)       ~/.cfg/perl+mine/bin/cpan    # stow or other package       
                  |-------|             # management tool.  Only one  
                      \_________        # tool should ever be used at 
                                \       # any given time, hence it's  
                        symlink  |      # nicer to call it ~/.cfg than
                                 v      # ~/.Stow or similar. 
                              |-------| 
 (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan   # for flexible
                                                   # sourcecontrol

Explanation and justification of this design follows:

=over 4

=item * Flexibility

The flexibility of mapping between (2) and (3) offered by the
F<etc/config.map> file lets us squash multiple sources into the same
unique package namespace.  Advantages:

  + Can have parallel public/private/"retired" hierarchies
    within the CVS repository.

  + Allows management of config concurrently from several different
    source control systems.

=item * Clear demarcation of responsibility

  + The symlinks between (1) and (2) are managed entirely by the
    chosen package management tool (currently stow).

  + The symlinks between (2) and (3) are managed entirely by this
    program and the F<etc/config.map> file.

=item * Cooperation with source control system

F<config> is currently a single CVS module so (3) must contain a
directory called F<config> for clean check-out.

=back

=head2 CAVEAT

We avoid F<~/.stow> because stow interprets F<.stow> existing in a
directory as a flag meaning that that directory is a stow directory
containing stow source packages.  As a result it will not remove any
stow symlinks from that directory, but we certainly want it to remove
stow symlinks from under F<~>.

=head1 TODO

=over 4

=back

=cut

# Now we define some sensible default settings for the top-level
# container directories corresponding to each level above:

# (1) Where the all-important end-user symlinks go.
$cfg{TARGET_DIR}  = $ENV{HOME};

# (2) Package directory ("stow directory" in stow terminology).
#     stow requires all packages live immediately under this.
$cfg{PKG_DIR}     = "$ENV{HOME}/.cfg";

# We use a slightly hacked-up version of GNU stow which ignores CVS/
# directories.
$cfg{STOW}        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
$cfg{MAP_FILE}    = abs_path("$RealBin/../etc/config.map");

##############################################################################

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin $RealScript);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use Sh qw(abs_path);
use Cfg;
use Cfg::Utils qw(%opts %cfg);

Getopt::Long::Configure('no_ignore_case');
GetOptions(
  \%opts,
  'dry-run|n', 'sources|s', 'destinations|d', 'verbose|v+',
  'pkg-dir|p=s', 'target|t=s', 'map|m=s',
  'delete|D', 'remove-dangling|r', 'thorough|T',
)
  or usage();

sub usage {
  warn @_, "\n" if @_;

  die <<EOUSAGE;
$RealScript [options] [pkg [pkg...]]

Installs the listed config packages, or all if none are specified.

Options [defaults in square brackets]:
  -s, --sources              Only list source packages
  -D, --destinations         Only list destination packages
  -n, --dry-run              Don't touch the disk
  -v, --verbose              Increase verbosity
  -p, --pkg-dir=DIR          Change source package [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$cfg{TARGET_DIR}]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -D, --delete               Delete the chosen packages, not install
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
EOUSAGE
}

$cfg{PKG_DIR}     = $opts{'pkg-dir'} if $opts{'pkg-dir'};
$cfg{TARGET_DIR}  = $opts{'target' } if $opts{'target' };
$cfg{MAP_FILE}    = $opts{'map'    } if $opts{'map'    };

-d $cfg{TARGET_DIR}
  or usage("$cfg{TARGET_DIR} is not a valid directory; aborting.\n");
-e $cfg{MAP_FILE}
  or usage("$cfg{MAP_FILE} does not exist; did you copy from $cfg{MAP_FILE}.template?\n");
-e $cfg{STOW}
  or usage("$cfg{STOW} not found!  Aborting.\n");

lstat($cfg{PKG_DIR});
if (-e _) {
  -d _ or usage("$cfg{PKG_DIR} must be a directory!  Aborting.\n");
}
else {
  mkdir $cfg{PKG_DIR} or die "mkdir($cfg{PKG_DIR}) failed: $!\n";
}

Cfg->do_registration();

if ($opts{sources} || $opts{destinations}) {
  Cfg->list_pkgs();
  exit 0;
}

Cfg->process_pkgs();

exit 0;

