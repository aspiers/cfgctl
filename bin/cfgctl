#!/usr/bin/perl

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use File::Compare;
use Sh qw(abs_path move_with_subpath);

# Pathname strategy involves multiple levels of symlinks, e.g.:
#
# (1)                      ~/bin/cpan   # These are the filenames
#                                |--|   # which actually get used
#                                  |    # as config etc.
#                                  v  
#                                |--| 
# (2)       ~/.cfg/perl+mine/bin/cpan   # Flat namespace required for
#                  |_______|            # stow or other package management
#                      \_________       # tool.  Only one tool should ever be
#                                \      # used at any given time, hence it's
#                                 |     # nicer to call it ~/.cfg than ~/.Stow
#                                 v     # or similar.
#                              |-------| 
# (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan   # for flexible
#                                                   # sourcecontrol
#
# Note:
#
#   * The symlinks between (1) and (2) are managed entirely by the
#     chosen package management tool (currently stow).
#
#   * The symlinks between (2) and (3) are managed entirely by this
#     program and the etc/config.map file.
#
#   * 'config' is a single CVS module so (3) must contain a directory
#     called 'config'.
#
#   * The flexibility of mapping between (2) and (3) offered by the
#     etc/config.map file lets us squash multiple sources into the
#     same unique package namespace.  Advantages:
#
#       + Can have parallel public/private/RETIRED hierarchies
#         within the CVS repository.
#
#       + Could even manage config concurrently from several different
#         source control systems.
#
#   * We avoid ~/.stow because stow interprets ".stow" existing in a
#     directory as a flag meaning that that directory is a stow
#     directory containing stow source packages.  As a result it will
#     not remove any stow symlinks from that directory, but we certainly
#     want it to remove stow symlinks from under ~
#

# Now we define the top-level container directories corresponding to
# each level:

# (1) Where the all-important symlinks go.
my $TARGET_DIR  = $ENV{HOME};

# (2) Package directory ("stow directory" in stow terminology).
#     stow requires all packages live immediately under this.
my $PKG_DIR     = "$ENV{HOME}/.cfg";

# We use a slightly hacked-up version of GNU stow which ignores CVS/
# directories.
my $STOW        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
my $MAP_FILE    = abs_path("$RealBin/../etc/config.map");

my %opts;
Getopt::Long::Configure('no_ignore_case');
GetOptions(
  \%opts,
  'dry-run|n', 'debug|d',
  'pkg-dir|p=s', 'target|t=s', 'map|m=s',
  'delete|D', 'remove-dangling|r',
)
  or die "Bad options";

my $for_real = $opts{'dry-run'} ? 0 : 1;
$PKG_DIR     = $opts{'pkg-dir'} if $opts{'pkg-dir'};
$TARGET_DIR  = $opts{'target' } if $opts{'target' };
$MAP_FILE    = $opts{'map'    } if $opts{'map'    };

-d $TARGET_DIR
  or die "$TARGET_DIR is not a valid directory; aborting.\n";
-e $MAP_FILE
  or die "$MAP_FILE does not exist; did you copy from $MAP_FILE.template?\n";
-e $STOW
  or die "$STOW not found!  Aborting.\n";

if (-e $PKG_DIR) {
  -d $PKG_DIR or die "$PKG_DIR must be a directory!  Aborting.\n";
}
else {
  mkdir $PKG_DIR or die "mkdir($PKG_DIR) failed: $!\n";
}

if (@ARGV) {
  foreach my $pkg (@ARGV) {
    process_pkg($pkg);
  }
}
else {
  process_pkgs_from_config();
}

TempDir->cleanup();

exit 0;

sub process_pkgs_from_config {
  my %repos;

  open(MAP, $MAP_FILE) or die "open($MAP_FILE) failed: $!\n";
  while (<MAP>) {
    if (/^\s*\#\@/) {
      print;
      next;
    }
    next if /^\s*(\#|$)/;

    chomp;
    s/^\s+//;
    s/\s+$//;

    if (/^%repo\((.+)\)\s+(\S+)\s*=\s*(.+)$/) {
      my ($type, $label, $root) = ($1, $2, $3);
      $root =~ s!^~/!$ENV{HOME}/!;
      $repos{$label} = {
        type => $type,
        root => $root,
      };
      print "#* Registered $type repo at $root\n";
      next;
    }

    my ($repo, $src, $dst) = split /\s+/, $_;
    $dst or die "Invalid line $. in $MAP_FILE:\n$_\n";
    $repos{$repo} or die "Invalid repository $repo in line $. of $MAP_FILE:\n$_\n";

    process_pkg($repos{$repo}, $src, $dst);
  }
}

sub process_pkg {
  my ($repo, $src, $dst) = @_;

  maybe_check_out_pkg($repo, $src);
  
  ensure_correct_symlink(
    File::Spec->join($PKG_DIR, $dst),
    File::Spec->join($repo->{root}, $src),
  );

  if ($src =~ /RETIRE/) {
    print "#! deprecating: $src\n";
    deprecate_pkg($src, $dst);
  }
  else {
    if ($opts{delete}) {
      delete_pkg($dst);
      print "# de-installed: $src\n";
    }
    else {
      install_pkg($dst);
      print "# installed: $src\n";
    }
  }
}

sub maybe_check_out_pkg {
  my ($repo, $src) = @_;

  if ($repo->{type} eq 'cvs') {
    maybe_check_out_cvs_pkg($repo, $src);
  }
  # support for other SCMs go here
  else {
    die "Repo type $repo->{type} not supported yet for $src; aborting.\n";
  }
}

sub maybe_check_out_cvs_pkg {
  my ($repo, $src) = @_;
  
  if (-d File::Spec->join($repo->{root}, $src)) {
    debug("# $src already checked out in $repo->{root}\n");
    return;
  }
  
  chdir($repo->{root}) or die "chdir($repo->{root}) failed: $!\n";
  print "Checking out $src ...\n";
  system 'cvs', 'checkout', $src;
  my $exit = $? >> 8;
  die "cvs checkout $src failed; aborting!\n" if $exit != 0;
}

sub deprecate_pkg {
  my ($src, $dst) = @_;
  debug("$src is deprecated; checking not installed ...\n");
  system $STOW,
      '-c',            # Dummy run, checking for conflicts.  If we're
                       # not using the deprecated package, there won't
                       # be any.
      '-R',            # Remove any symlinks already there.
      '-t', $TARGET_DIR,
      '-d', $PKG_DIR,
      $dst;
  my $exit = $? >> 8;
  warn "$STOW -c failed; aborting!\n" if $exit != 0;
}

sub delete_pkg {
  my ($dst) = @_;
  system $STOW,
      ($for_real ? () : ( '-n' )),
      '-D', 
      '-t', $TARGET_DIR,
      '-d', $PKG_DIR,
      $dst;
  my $exit = $? >> 8;
  warn "$STOW -c failed; aborting!\n" if $exit != 0;
}

sub install_pkg {
  my ($dst) = @_;
  my $stow_args = qq{-t "$TARGET_DIR" -d "$PKG_DIR" "$dst"};
  $stow_args = "-vvv $stow_args" if $opts{debug};
  my $cmd       = "$STOW -c -R $stow_args";
  (my $human_cmd = $cmd) =~ s!\b$ENV{HOME}/!~/!g;
  debug("preempt: $cmd\n");
  open(STOW, "$cmd 2>&1 |") or die "open($human_cmd|) failed: $!\n";
  while (<STOW>) {
    if (/^CONFLICT: (.+) vs. (.+?)( \(.*?\))?$/) {
      #print;
      my ($src, $symlink) = ($1, $2);
      preempt_conflict($src, $symlink);
      next;
    }
    
    #debug("! surplus stow -c output: $_");
    print "$_";
  }
  close(STOW) or die "close($human_cmd|) failed: $!\n";

  # Should have preempted all conflicts now; run for real.
  $cmd = "$STOW -R $stow_args";
  ($human_cmd = $cmd) =~ s!(^|\s)$ENV{HOME}/!$1~/!g;
  debug("post-preempt: $human_cmd\n");
  if ($for_real) {
    system $cmd;
    my $exit = $? >> 8;
    warn "$STOW failed; aborting!\n" if $exit != 0;
  }
}

sub preempt_conflict {
  my ($src, $symlink) = @_;

  debug("preempting conflict between $src and $symlink\n");

  # Shorter, human-readable versions of source file and symlink
  (my $human_src     = $src)     =~ s!^$ENV{HOME}/!~/!;
  (my $human_symlink = $symlink) =~ s!^$ENV{HOME}/!~/!;
  (my $sub_symlink   = $symlink) =~ s!^$TARGET_DIR/!!
    or die "$symlink didn't start with $TARGET_DIR\n";

  return if -d $symlink and -d $src;

  die "$human_symlink is a directory but $human_src isn't; aborting!\n"
    if -d $symlink and ! -d $src;
  
  if (! -d $symlink and ! -l $symlink and -d $src) {
    die "$human_src is a directory but $human_symlink isn't; aborting!\n";
  }

#   my $tempdir = TempDir->get;
#   die unless -d $tempdir;

  my ($src_dev,     $src_ino)     = stat($src) or die "stat($src) failed: $!";
  my ($symlink_dev, $symlink_ino) = stat($symlink);

  if (! $symlink_dev || ! $symlink_ino) {
    if (-l $symlink) {
      if ($opts{'remove-dangling'}) {
        debug("! Removing dangling symlink $symlink\n");
        if ($for_real) {
          unlink($symlink) or die "unlink($symlink) failed: $!\n";
        }
        return;
      }
      else {
        die "stat($symlink) failed ($!); invalid symlink?  Specify -r to remove dangling symlinks.\n";
      }
    }
    else {
      die "stat($symlink) failed ($!); can't preempt conflict!  Aborting.\n";
    }
  }

  if ($src_dev == $symlink_dev and $src_ino == $symlink_ino) {
    debug("$human_src and $human_symlink are the same file; must be false conflict (see 6.3 Conflicts section of manual)\n");
    return;
  }

  if (compare($src, $symlink) == 0) {
    # same file contents - remove target so that stow can put a
    # symlink there instead.
    debug("# $human_symlink == $src; remove to make way for symlink\n");
#     my $same_dir = File::Spec->join($tempdir, 'same');
#     die $same_dir unless -d $same_dir;
    if ($for_real) {
      unlink $symlink or die "unlink($symlink) to preempt conflict failed: $!\n";
      #move_with_subpath($TARGET_DIR, $same_dir, $sub_symlink);
    }
  }
  else {
    # different file contents - move target to source so that stow
    # can put a symlink there instead whilst still preserving
    # local changes
#     my $modified_dir = File::Spec->join($tempdir, 'modified');
    debug("# $human_symlink != $human_src; mv to preserve changes\n");
    if ($for_real) {
      my $host = $ENV{HOST} || $ENV{HOSTNAME} || die "edge case";
      my $suffix = "saved.$host.$$." . time();
      rename $src, "$src.$suffix"
        or die "rename($src, $src.$suffix) failed: $!\n";
      print "$src saved as $src.$suffix\n";
      rename $symlink, $src
	or die "rename($symlink, $src) to preempt conflict failed: $!\n";
      #move_with_subpath($TARGET_DIR, $modified_dir, $sub_symlink);
    }
  }
}

sub ensure_correct_symlink {
  my ($symlink, $required_target) = @_;

  if (! lstat $symlink) {
    symlink $required_target, $symlink
      or die "symlink($required_target, $symlink) failed: $!\n";
    return;
  }

  if (! -l $symlink) {
    die "$symlink already exists but is not a symlink; aborting!\n";
  }

  my ($a_dev, $a_ino) = stat($symlink) # stat automatically follows symlinks
    or die "stat($symlink) failed ($!); invalid symlink?\n";
  my ($r_dev, $r_ino) = stat($required_target)
    or die "stat($required_target) failed: $!";
  if ($a_dev != $r_dev or $a_ino != $r_ino) {
    die "$symlink already exists and points to the wrong place; aborting!\n";
  }
}

sub debug {
  warn @_ if $opts{debug};
}

##############################################################################

package TempDir;

use File::Basename;
use File::Path;
use File::Spec;
use File::Temp qw/ tempfile tempdir /;

our $tempdir;
my $init = 0; # yuk
my @subdirs;

sub init {
  return if $init;
  @subdirs = (qw/same modified/);
  $init++;
}

sub get {
  shift->init();
  return $tempdir if $tempdir;
  my $me = basename($0);
  $tempdir = tempdir(".$me.XXXXXXXX", DIR => $TARGET_DIR);
  die "huh?" unless -d $tempdir;
  die unless @subdirs;
  foreach my $dir (@subdirs) {
    my $new = File::Spec->join($tempdir, $dir);
    mkdir($new) or die "mkdir($new) failed: $!\n";;
  }
  return $tempdir;
}

sub cleanup {
  return unless $tempdir and -d $tempdir;
  foreach my $dir (@subdirs) {
    my $doomed = File::Spec->join($tempdir, $dir);
    rmdir($doomed) or die "$doomed not empty?";
  }
  rmdir($tempdir) or die "rmdir($tempdir) failed: $!\n";
}

END {
  if ($tempdir and -e $tempdir) {
    warn "! Did not exit cleanly; $tempdir still exists.\n";
  }
}

1;
