#!/usr/bin/perl

=head1 NAME

cfgctl - configuration file controller

=head1 SYNOPSIS

    $ cfgctl [options] [pkg [pkg...]]

By default, installs the listed config packages, or all if none are
specified.

Options [defaults in square brackets]:

  -i, --install              Fetch the chosen packages, then install
  -U, --update               Update or fetch the chosen packages, then re-install
  -e, --erase                De-install the chosen packages

  -s, --sources              Only list source packages
  -d, --destinations         Only list destination packages

  -t, --test                 Dry run, don't touch the disk
  -v, --verbose[=N]          Increase [specify] verbosity

  -p, --pkg-dir=DIR          Change source package directory [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$cfg{TARGET_DIR}]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
  -T, --thorough             Don't prune subdirectories not in packages.
                             This may leave symlinks pointing to old
                             dirs which used to be in packages, but is
                             a lot slower.

=cut

# Now we define some sensible default settings for the top-level
# container directories corresponding to each level described in the
# architecture document:

# (1) Where the all-important end-user symlinks go.
$cfg{TARGET_DIR}  = $ENV{HOME};

# (2) Package directory ("stow directory" in stow terminology).
#     stow requires all packages live immediately under this.
$cfg{PKG_DIR}     = "$ENV{HOME}/.cfg";

# We use a slightly hacked-up version of GNU stow which ignores CVS/
# directories and anything in ~/.cvsignore.
$cfg{STOW}        = "$RealBin/stow";

# This is where we configure which config packages we want installed locally.
$cfg{MAP_FILE}    = abs_path("$RealBin/../etc/config.map");

##############################################################################

use strict;
use warnings;

use File::Spec;
use FindBin qw($RealBin $RealScript);
use Getopt::Long;

use lib "$RealBin/../lib/perl5";
use Sh qw(abs_path);
use Cfg;
use Cfg::Utils qw(debug %opts %cfg);

Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions(
  \%opts,
  'install|i', 'freshen|F', 'update|U', 'erase|e',
  'sources|s', 'destinations|d',
  'test|t', 'verbose|v:+',
  'pkg-dir|p=s', 'target|t=s', 'map|m=s',
  'remove-dangling|r', 'thorough|T',
)
  or usage();

sub usage {
  warn @_, "\n" if @_;

  ### N.B.!  If you change the below, don't forget to update the
  ### SYNOPSIS too!
  die <<EOUSAGE;
$RealScript [options] [pkg [pkg...]]

By default, installs the listed config packages, or all if none are
specified.

Options [defaults in square brackets]:
  -i, --install              Fetch the chosen packages, then install
  -U, --update               Update or fetch the chosen packages, then re-install
  -e, --erase                De-install the chosen packages

  -s, --sources              Only list source packages
  -d, --destinations         Only list destination packages

  -t, --test                 Dry run, don't touch the disk
  -v, --verbose[=N]          Increase [specify] verbosity

  -p, --pkg-dir=DIR          Change source package directory [$cfg{PKG_DIR}]
  -t, --target=TARGET-DIR    Change target directory [$cfg{TARGET_DIR}]
  -m, --map=MAP-FILE         Change config map file [$cfg{MAP_FILE}]
  -r, --remove-dangling      If conflicts with dangling symlinks
                             are found, delete them.
  -T, --thorough             Don't prune subdirectories not in packages.
                             This may leave symlinks pointing to old
                             dirs which used to be in packages, but is
                             a lot slower.
EOUSAGE
}

$cfg{PKG_DIR}     = $opts{'pkg-dir'} if $opts{'pkg-dir'};
$cfg{TARGET_DIR}  = $opts{'target' } if $opts{'target' };
$cfg{MAP_FILE}    = $opts{'map'    } if $opts{'map'    };

-d $cfg{TARGET_DIR}
  or usage("$cfg{TARGET_DIR} is not a valid directory; aborting.\n");
-e $cfg{MAP_FILE}
  or usage("$cfg{MAP_FILE} does not exist; did you copy from $cfg{MAP_FILE}.template?\n");
-e $cfg{STOW}
  or usage("$cfg{STOW} not found!  Aborting.\n");

lstat($cfg{PKG_DIR});
if (-e _) {
  -d _ or usage("$cfg{PKG_DIR} must be a directory!  Aborting.\n");
}
else {
  mkdir $cfg{PKG_DIR} or die "mkdir($cfg{PKG_DIR}) failed: $!\n";
}

my $total = $opts{sources} + $opts{destinations} + $opts{update} + $opts{erase};
if ($total == 0) {
  $opts{install}++;
}
elsif ($total > 1) {
  usage("Only one of -i/-U/-e/-s/-d can be specified.\n");
}

Cfg->do_registration();

if ($opts{sources} || $opts{destinations}) {
  Cfg->list_pkgs();
  exit 0;
}

my $queue = Cfg->get_pkg_queue;
exit 1 if $queue->empty;

if ($opts{update}) {
  Cfg->update($queue->pkgs);
  exit 0 if $opts{'dry-run'};
}
elsif ($opts{install} || $opts{erase}) {
  Cfg->ensure_src_local($queue->pkgs);
}
else {
  die "BUG";
}

foreach my $section_and_pkgs ($queue->sections_and_pkgs) {
  my ($section, $pkgs) = @$section_and_pkgs;
  debug(1, "#>>> ", $section->to_string); 
  foreach my $pkg (@$pkgs) {
    my $description = $pkg->description;
    my $dst         = $pkg->dst;

    $pkg->ensure_install_symlink;

    if ($pkg->deprecated) {
      debug(1, "#! DEPRECATING: $description");
      $pkg->deprecate;
      return;
    }

    if ($opts{erase}) {
      debug(1, "# Deinstalling: $description");
      $pkg->deinstall;
    }
    else {
      debug(1, "# Installing: $description");
      $pkg->install;
    }
  }
}

exit 0;

