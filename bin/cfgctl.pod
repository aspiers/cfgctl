=head1 MOTIVATION

Home directories on UNIX-like systems contain a wealth of
configuration data, which is typically treated as a "second-class
citizen" in comparison to source code.  The latter is generally
subject to standard modern software configuration management best
practices which allow consistent deployment, auditing, roll-back and
so on, whereas the former is usually managed in an ad-hoc and
uncontrolled manner.

There appears to be no reasonable justification for this inequality of
treatment with respect to configuration based in home directories.  It
is this writer's belief that it exists for the following reasons:

=over 4

=item * It's awkward to manage.

Configuration usually lives directly under the home directory rather
than in several conveniently self-contained trees which can easily be
checked into a source code control system.

=item * It often blurs the lines between code and data.

For example, options set in your shell profile are conceptually
configuration data, but are implemented by running shell code commands
(set/setopt etc.)

=item * Most people don't bother with complex configurations anyway, and

=item * configuration is often mostly forgotten about after start-up costs.

Many people only configure to "scratch an itch".

=item * Many people don't frequently use more than one system.

Or if they do, they are content to have a clear separation of
functionality between the systems, e.g. work vs. home.

=item * Configuration is often auto-generated by a front-end.

Therefore the user is often unaware of the back-end files even existing.

=item * System administrators generally take a very hands-off approach. 

With the exception of the canonical template skeleton user home
directory (e.g. F</etc/skel>) which is used to populate a new home
directory after creation, generally system administrators do not
attempt to change per-user configuration data in any way.  Taking a
naive political view, this would appear to be a very good thing ("get
your hands off MY files!").  However, many system administrators would
most likely not think twice about upgrading a system-wide package,
which could have exactly the same effect.  For example, imagine an
application C<foo> which looks for configuration data in
F</etc/foo/default.rc> and F<~/.foorc>.  After an upgrade which
changed the contents of F</etc/foo/default.rc>, a user might or might
not see different behaviour from the application, depending on:

    (a) whether F<~/.foorc> completely overrides F<default.rc> if
        present, or merely inherits defaults from F<default.rc> and
        then overrides them on a case-by-case basis, and

    (b) whether on the user's first invocation of the application,
        the application creates F<~/.foorc> before or after the user
        customises any options.

Now imagine that the application actually uses several per-user
configuration files.  (This is a very common scenario.)  Perhaps it
makes sense for some of these files to be configured site-wide, but
others per-user.  Or perhaps there are multiple versions of the
application co-installed, but they all use the same per-user
configuration directory.  In either case, the traditional approach
above may not be capable of yielding the right results.

=back

It seems clear that for anyone who uses more than one system, is fussy
about how they configure their tools, and wants consistent,
reproducible, audited, well-controlled configuration across multiple
systems, some kind of configuration management tool is required.

=head1 DESCRIPTION

This program aims to be that tool.  It divides configuration into
well-defined "chunks" (stow packages) which can be managed by the
user's favourite source code control tool(s).  It then reuses the code
and functionality of GNU stow in order to install the files within
these packages into the expected location within the home directory
for normal operation.

=head1 ARCHITECTURE

The pathname strategy involves two levels of symlinks.  We take the
example of a simple shell-script called F<cpan> which invokes the
well-known CPAN shell and is required to live under F<~/bin>.  We
could just as easily have taken a more typical configuration file such
as F<~/.bashrc>, but for illustrative purposes it is better to choose
something which does not live directly under F<~>.

 (1)                      ~/bin/cpan             "install targets"
                                  | 
                                  |              "install symlinks"
                                  V
 (2)       ~/.cfg/perl+mine/bin/cpan             "install sources"
                  <------->                      "pkg name"
           <-------------->                      "cfg target"
                      \_____________
                                    \
                                    |            "cfg symlink"
                                    V
      <------------------------------->          "cfg source"
 (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan

=head2 Explanation

(N.B. In the following text, the use of the words "source" and
"target" may appear backwards to what would be intuitively expected.
This is because the mechanism used to "install" from "source" to
"target" is symlinking, which results in a symlink pointing from the
"target" back to the "source".  For example, see the L<ln(1)> man page
for somewhat contradictory terminology, where "target" refers to the
thing being pointed to.  So here we could say that the "cfg source" is
the target of the "cfg symlink", if we wanted to be really confusing!)

At the first level of symlinks, we have the "install targets" (1)
which are the pathnames which actually get used as config etc.  They
are "install symlinks" pointing to the "install sources" pathnames (2)
(unless stow folding is used, in which case the same will be true for
a containing directory).  There will usually be many of these for each
package.

At the second level, we have one "cfg symlink" per package pointing
from a "cfg target" to a "cfg source" directory.  This provides a flat
package namespace as required for stow or other package management
tool.  Only one tool should ever be used at any given time, hence it's
nicer to call it F<~/.cfg> than F<~/.Stow> or similar.

(An additional reason for not calling it F<~/.stow> is that stow
interprets any directory entry F<.stow> as a flag meaning that that
directory is a stow directory containing stow source packages.  As a
result it will not remove any stow symlinks from that directory, but
we certainly want it to remove stow symlinks from under F<~>.)

=head2 Justification

=over 4

=item * Flexibility

The flexibility of this two-layer mapping lets us squash multiple
sources into the same unique package namespace.  Advantages:

  + Allows use and management of config concurrently from several
    different source control systems / repositories.

  + Can use parallel public/private/"retired" hierarchies within one
    source control system (e.g. within one CVS/Subversion repository).

=item * Clear demarcation of responsibility

  + The symlinks between (1) and (2) are managed entirely by the
    chosen package management tool (currently stow).  The code will
    refer to them as "install symlinks".

  + The symlinks between (2) and (3) are managed entirely by this
    program and the F<etc/config.map> file.  The code will refer to
    them as "cfg symlinks".

=item * Cooperation with source control system

F<config> is currently a single CVS module so (3) must contain a
directory called F<config> for clean check-out.

=back

=head1 TODO

=over 4

=item * Support more source code control systems.

This is accomplished by adding more subclasses of C<Cfg::Pkg::Base>.

=back

=cut
