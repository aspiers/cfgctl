=head1 NAME

cfgctl - configuration file controller

=head1 SYNOPSIS

    $ cfgctl --help

=head1 MOTIVATION

Home directories on UNIX-like systems contain a wealth of
configuration data, which is typically treated as a "second-class
citizen" in comparison to source code.  The latter is generally
subject to standard modern software configuration management best
practices which allow consistent deployment, auditing, roll-back and
so on, whereas the former is usually managed in an ad-hoc and
uncontrolled manner.

There appears to be no reasonable justification for this inequality of
treatment with respect to configuration based in home directories.  It
is the author's belief that it exists for the following reasons:

=over 4

=item * It's awkward to manage.

Configuration usually lives directly under the home directory rather
than in several conveniently self-contained trees which can easily be
checked into a source code control system.

=item * It often blurs the lines between code and data.

For example, options set in your shell profile are conceptually
configuration data, but are implemented by running shell code commands
(set/setopt etc.)

=item * Most people don't bother with complex configurations anyway, and

=item * configuration is often mostly forgotten about after start-up costs.

Many people only configure to "scratch an itch".

=item * Many people don't frequently use more than one system.

Or if they do, they are content to have a clear separation of
functionality between the systems, e.g. work vs. home.

=item * Configuration is often auto-generated by a front-end.

Therefore the user is often unaware of the back-end files even existing.

=item * System administrators generally take a very hands-off approach. 

With the exception of the canonical template skeleton user home
directory (e.g. F</etc/skel>) which is used to populate a new home
directory after creation, generally system administrators do not
attempt to change per-user configuration data in any way.  Taking a
naive political view, this would appear to be a very good thing ("get
your hands off MY files!").  However, many system administrators would
most likely not think twice about upgrading a system-wide package,
which could have exactly the same effect.  For example, imagine an
application C<foo> which looks for configuration data in
F</etc/foo/default.rc> and F<~/.foorc>.  After an upgrade which
changed the contents of F</etc/foo/default.rc>, a user might or might
not see different behaviour from the application, depending on:

    (a) whether F<~/.foorc> completely overrides F<default.rc> if
        present, or merely inherits defaults from F<default.rc> and
        then overrides them on a case-by-case basis, and

    (b) whether on the user's first invocation of the application,
        the application creates F<~/.foorc> before or after the user
        customises any options.

Now imagine that the application actually uses several per-user
configuration files.  (This is a very common scenario.)  Perhaps it
makes sense for some of these files to be configured site-wide, but
others per-user.  Or perhaps there are multiple versions of the
application co-installed, but they all use the same per-user
configuration directory.  In either case, the traditional approach
above may not be capable of yielding the right results.

=back

It seems clear that for anyone who uses more than one system, is fussy
about how they configure their tools, and wants consistent,
reproducible, audited, well-controlled configuration across multiple
systems, some kind of configuration management tool is required.

=head1 DESCRIPTION

This program aims to be that tool.  It divides configuration into
clearly delineated chunks (stow packages) which can be managed by the
user's favourite source code control tool(s).  It then reuses the code
and functionality of GNU stow in order to install the files within
these packages into the expected location within the home directory
for normal operation.

Furthermore, there is nothing limiting the scope of this program's
usefulness solely to management of configuration data and code.  It is
in fact a generic package management system which can take packages
data and code from a number of different sources, collapse them into a
single package repository with a flat namespace, and from this
repository install individual packages into (and uninstall from) a
live production directory hierarchy in which they will actually be
used.

=head1 DIFFERENCES FROM OTHER PACKAGE MANAGEMENT SYSTEMS

This tool is similar in concept to tools such as C<rpm> and C<dpkg>,
but has a slightly different scope.

=over 4

=item * It is intended to be used by (many) non-root users.

Yes, you can run C<rpm> and C<dpkg> non-root, and create relocatable
packages, but ultimately they're designed for managing an OS install,
and their quirks are distribution-specific.

=item * It is intended for fluid environments.

C<rpm> is part of a stricter release cycle.  To make a change to the
system, you need to update or patch the "pristine source", rebuild the
F<.rpm> or F<.deb>, then install the newer version.  This tool relies
on symlinks, so you can edit the source files, or update them from
their upstream provider via a unified interface to the revision
control system backends, and the new version will instantly become
active.

=back

=head1 ARCHITECTURE (at the file-system level)

The pathname strategy involves two levels of symlinks.  We take the
example of a simple shell-script called F<cpan> which invokes the
well-known CPAN shell and is required to live under F<~/bin>.  We
could just as easily have taken a more typical configuration file such
as F<~/.bashrc>, but for illustrative purposes it is better to choose
something which does not live directly under F<~>.

 (1)                      ~/bin/cpan             "install targets"
                                  | 
                                  |              "install symlinks"
                                  V
 (2)       ~/.cfg/perl+mine/bin/cpan             "install sources"
           <----->                               "packages directory"
                  <------->                      "package name"
           <-------------->                      "package target"
                      \_____________
                                    \
                                    |            "package symlink"
                                    V
      <------------------------------->          "package source"
 (3)  ~/.cvs/config/dev-tools/perl/mine/bin/cpan

=head2 Explanation

(N.B. In the following text, the use of the words "source" and
"target" may appear backwards to what would be intuitively expected.
This is because the mechanism used to "install" from "source" to
"target" is symlinking, which results in a symlink pointing from the
"target" back to the "source".  For example, see the L<ln(1)> man page
for somewhat contradictory terminology, where "target" refers to the
thing being pointed to.  So here we could say that the "package
source" is the target of the "package symlink", if we wanted to be
really confusing!)

At the first level of symlinks, we have the "install targets" (1)
which are the pathnames which actually get used as config etc.  They
are "install symlinks" pointing to the "install sources" pathnames (2)
(unless stow folding is used, in which case the same will be true for
a containing directory).  There will usually be many of these for each
package.

At the second level, we have one "package symlink" per package
pointing from a "package target" to a "package source" directory.
This provides a flat package namespace as required for stow or other
package management tool.  Only one tool should ever be used at any
given time, hence it's nicer to call it F<~/.cfg> than F<~/.Stow> or
similar.

(An additional reason for not calling it F<~/.stow> is that stow
interprets any directory entry F<.stow> as a flag meaning that that
directory is a stow directory containing stow source packages.  As a
result it will not remove any stow symlinks from that directory, but
we certainly want it to remove stow symlinks from under F<~>.)

=head2 Justification

The flexibility of this two-layer mapping lets us squash multiple
sources into the same unique package namespace.  The advantages of
this approach are:

=over 4

=item * Clear exposition of package namespace

The package namespace is clearly visible in the filesystem, under the
packages directory (F<~/.cfg> by default).  So for instance you could
recursively run C<grep> or C<find> on it.

=item * Flexibility

  + Allows use and management of config concurrently from several
    different source control systems / repositories.

  + Can use parallel public/private/"retired" hierarchies within one
    source control system (e.g. within one CVS/Subversion repository).

  + Could perform an "emergency deinstall" or switch of an active
    package even without this tool, simply by removing or repointing a
    single symlink.

=item * Clear demarcation of responsibility

FIXME: As the stow code gets merged in, this becomes a less compelling
argument.

  + The symlinks between (1) and (2) are managed entirely by the
    chosen package management tool (currently stow).  The code will
    refer to them as "install symlinks".

  + The symlinks between (2) and (3) are managed entirely by this
    program and the F<etc/config.map> file.  The code will refer to
    them as "package symlinks".

=item * Cooperation with source control system

F<config> is currently a single CVS module so (3) must contain a
directory called F<config> for clean check-out.

=back

=head1 TODO

=over 4

=item * Renaming

This tool is not relevant exclusively to management of
configuration-related data and code, so all the "cfg" nomenclature
should go.

=item * Support more source code control systems.

This is accomplished by adding more subclasses of C<Cfg::Pkg::Base>.

=back

=cut
